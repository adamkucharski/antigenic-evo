dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=3,bandW=20) # Generate maps
landscape.plot(dataload,radius1=25,yearload=2009,groupN=2)
reproduction.number.plot(dataload)
landscape.build(dataload,0.5,extendD=3,bandW=20) # Generate maps
# Plot data
landscape.plot(dataload,radius1=25,yearload=2009,groupN=2)
reproduction.number.plot(dataload)
rm(list=ls())
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=3,bandW=20) # Generate maps
# Plot data
landscape.plot(dataload,radius1=25,yearload=2009,groupN=2)
reproduction.number.plot(dataload)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=20) # Generate maps
# Plot data
landscape.plot(dataload,radius1=25,yearload=2009,groupN=2)
reproduction.number.plot(dataload)
#titre.plot(dataload)
#proct.plot(dataload)
load(paste("R_datasets/",Data.load,"_V.RData",sep=""))
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Construct matrix of map coords
x.range=seq(floor(min(ag.coord$AG_x)-1),ceiling(max(ag.coord$AG_x)),d.step)
y.range=seq(floor(min(ag.coord$AG_y)),ceiling(max(ag.coord$AG_y)+extendD),d.step)
points.j=expand.grid(x.range,y.range) # Define list of points to evaluate
names(points.j)=c("agx","agy")
npointsj=length(points.j[,1])
aA=bandW # Define local bandwidth (set as 11 in paper)
ag.weights=matrix(NA,nrow=npointsj,ncol=nstrains)
for(ii in 1:npointsj){
for(jj in 1:nstrains){
a_ij=sqrt((points.j[ii,"agx"]-ag.coord[jj,"AG_x"])^2+(points.j[ii,"agy"]-ag.coord[jj,"AG_y"])^2)
ag.weights[ii,jj]=ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
Data.load = dataload ; d.step=1 ; extendD=3 ; bandW=20; bootstrap = 5; Nsamp = 10
load(paste("R_datasets/",Data.load,"_V.RData",sep=""))
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Construct matrix of map coords
x.range=seq(floor(min(ag.coord$AG_x)-1),ceiling(max(ag.coord$AG_x)),d.step)
y.range=seq(floor(min(ag.coord$AG_y)),ceiling(max(ag.coord$AG_y)+extendD),d.step)
points.j=expand.grid(x.range,y.range) # Define list of points to evaluate
names(points.j)=c("agx","agy")
npointsj=length(points.j[,1])
aA=bandW # Define local bandwidth (set as 11 in paper)
ag.weights=matrix(NA,nrow=npointsj,ncol=nstrains)
for(ii in 1:npointsj){
for(jj in 1:nstrains){
a_ij=sqrt((points.j[ii,"agx"]-ag.coord[jj,"AG_x"])^2+(points.j[ii,"agy"]-ag.coord[jj,"AG_y"])^2)
ag.weights[ii,jj]=ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
ag.weights
image(ag.weights)
aA
a_ij
aA
ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
plot3D(ag.weights)
librart(plot3D)
library(plot3D)
plot3D(ag.weights)
surf3D(ag.weights)
surf3D(x=npointsj,y=nstrains,z=ag.weights)
surf3D(x=ag.weights)
library(plotly)
install.packages("plotly")
library(plotly)
plot_ly(z = ~ag.weights) %>% add_surface()
npointsj
nstrains
points.j
expand.grid(x.range,y.range)
x.range
y.range
points.j
x.range
y.range
d.step
bandW
ag.coord
plot_ly(z = ~ag.weights)
plot_ly(z = ~ag.weights) %>% add_surface()
ag.weights
aA
aA <- 30
ag.weights <- matrix(NA,nrow=npointsj,ncol=nstrains)
# How much weighting to give to strains in the fitting
for(ii in 1:npointsj){
for(jj in 1:nstrains){
a_ij <- sqrt((points.j[ii,"agx"]-ag.coord[jj,"AG_x"])^2+(points.j[ii,"agy"]-ag.coord[jj,"AG_y"])^2)
ag.weights[ii,jj] <- ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
plot_ly(z = ~ag.weights) %>% add_surface()
aA <- 10
ag.weights <- matrix(NA,nrow=npointsj,ncol=nstrains)
# How much weighting to give to strains in the fitting
for(ii in 1:npointsj){
for(jj in 1:nstrains){
a_ij <- sqrt((points.j[ii,"agx"]-ag.coord[jj,"AG_x"])^2+(points.j[ii,"agy"]-ag.coord[jj,"AG_y"])^2)
ag.weights[ii,jj] <- ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
plot_ly(z = ~ag.weights) %>% add_surface()
lm.data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set up fitting data set for group of participants
age.list <- as.numeric(data1[,2])
age.gp1 <- c(1:npart)[age.list<=19] #define young age
age.gp2 <- c(1:npart)[age.list>19] #define young age
group.list <- list(age.gp1,age.gp2)
group.names <- c("<20","20+")
n.groups <- length(group.list)
lm.data.group=NULL
for(kk in 1:n.groups){ #Loop of groups of interest
lm.d0 <- NULL
for(ii in group.list[[kk]]){ # Gather data for all relevant participants
p.data <- data1[ii,3:(nstrains+2)]
lm.data <- data.frame(matrix(NA,nrow=nstrains,ncol=3))
names(lm.data)=c("agx","agy","titre")
lm.data$titre <- as.numeric(p.data)
#lm.data$titre=probability.protection(2^as.numeric(p.data)*10)
lm.data$agx <- ag.coord$AG_x
lm.data$agy <- ag.coord$AG_y
lm.d0 <- rbind(lm.d0,lm.data)
}
lm.data.group[[kk]] <- lm.d0
}
lm.data
n.groups
lm.data
lm.data.group
n.groups
lm.data.group[[2]]
lm.data.group[[1]]
ag.weights
ag.weights
?plot_ly
x.range
y.range
ag.weights <- matrix(NA,nrow=length(x.range),ncol=length(y.range))
ag.weights
ag.coord
points.j
ag.weights <- matrix(NA,nrow=length(x.range),ncol=length(y.range))
pp <- 1
for(ii in 1:length(x.range)){
for(jj in 1:length(y.range)){
a_ij <- sqrt((x.range[ii]-ag.coord[pp,"AG_x"])^2+(y.range[jj]-ag.coord[pp,"AG_y"])^2)
ag.weights[ii,jj] <- ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
ag.weights
plot_ly(z = ~ag.weights) %>% add_surface()
aA
aA <- 20
plot_ly(z = ~ag.weights) %>% add_surface()
ag.weights <- matrix(NA,nrow=length(x.range),ncol=length(y.range))
pp <- 1
for(ii in 1:length(x.range)){
for(jj in 1:length(y.range)){
a_ij <- sqrt((x.range[ii]-ag.coord[pp,"AG_x"])^2+(y.range[jj]-ag.coord[pp,"AG_y"])^2)
ag.weights[ii,jj] <- ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
plot_ly(z = ~ag.weights) %>% add_surface()
ag.weights <- matrix(NA,nrow=length(x.range),ncol=length(y.range))
pp <- 2
for(ii in 1:length(x.range)){
for(jj in 1:length(y.range)){
a_ij <- sqrt((x.range[ii]-ag.coord[pp,"AG_x"])^2+(y.range[jj]-ag.coord[pp,"AG_y"])^2)
ag.weights[ii,jj] <- ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
plot_ly(z = ~ag.weights) %>% add_surface()
aA <- 100
ag.weights <- matrix(NA,nrow=length(x.range),ncol=length(y.range))
pp <- 2
for(ii in 1:length(x.range)){
for(jj in 1:length(y.range)){
a_ij <- sqrt((x.range[ii]-ag.coord[pp,"AG_x"])^2+(y.range[jj]-ag.coord[pp,"AG_y"])^2)
ag.weights[ii,jj] <- ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
plot_ly(z = ~ag.weights) %>% add_surface()
aA <- 10
ag.weights <- matrix(NA,nrow=length(x.range),ncol=length(y.range))
pp <- 2
for(ii in 1:length(x.range)){
for(jj in 1:length(y.range)){
a_ij <- sqrt((x.range[ii]-ag.coord[pp,"AG_x"])^2+(y.range[jj]-ag.coord[pp,"AG_y"])^2)
ag.weights[ii,jj] <- ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
plot_ly(z = ~ag.weights) %>% add_surface()
# Construct matrix of map coords
x.range <- seq(floor(min(ag.coord$AG_x)-1),ceiling(max(ag.coord$AG_x)),d.step)
y.range <- seq(floor(min(ag.coord$AG_y)),ceiling(max(ag.coord$AG_y)+extendD),d.step)
points.j <- expand.grid(x.range,y.range) # Define list of points to evaluate
names(points.j) <- c("agx","agy")
npointsj <- length(points.j[,1])
aA <- bandW # Define local bandwidth (set as 11 in Fonville paper)
ag.weights <- matrix(NA,nrow=npointsj,ncol=nstrains)
# How much weighting to give to strains in the fitting
for(ii in 1:npointsj){
for(jj in 1:nstrains){
a_ij <- sqrt((points.j[ii,"agx"]-ag.coord[jj,"AG_x"])^2+(points.j[ii,"agy"]-ag.coord[jj,"AG_y"])^2)
ag.weights[ii,jj] <- ifelse(a_ij<=aA,(1-(a_ij/aA)^3)^3,0) #a_ij #
}
}
plot_ly(z = ~ag.weights) %>% add_surface()
lm.data.group
n.groups
kk=1
#pick a point from points.j
pred.table=data.frame(matrix(NA,nrow=npointsj,ncol=3))
names(pred.table)=c("agx","agy","pred.titre")
lm.data=lm.data.group[[kk]]
lm.data
pp <- 1
rep(ag.weights[pp,],length(group.list[[kk]]))
ag.weights
pp
ag.weights[pp,]
length(group.list[[kk]])
agW=rep(ag.weights[pp,],length(group.list[[kk]])) # specify weights for fitting
agW
group.list[[kk]]
age.gp1
age.gp2
group.list[[kk]]
length(group.list[[kk]])
rep(ag.weights[pp,],length(group.list[[kk]]))
lm.data
fit.model
fit.model <- lm(titre ~ agx*agy,data=lm.data,weights=agW)
fit.model
?lm
pred.tableP
pred.table
#iterate through point from points.j
pred.table=data.frame(matrix(NA,nrow=npointsj,ncol=3))
names(pred.table)=c("agx","agy","pred.titre")
lm.data=lm.data.group[[kk]]
for(pp in 1:npointsj){
agW=rep(ag.weights[pp,],length(group.list[[kk]])) # specify weights for fitting
fit.model <- lm(titre ~ agx*agy,data=lm.data,weights=agW)
#summary(fit.model); predict(fit.model,newdata=points.j[pp,])
# predict titre for that point
pred.table[pp,] <- c(points.j[pp,],predict(fit.model,newdata=points.j[pp,]))
}
pred.table
pred.tableP <- sapply(pred.table$pred.titre,function(x){min(max(x,0),8)})
pred.matrix <- matrix(pred.tableP,byrow=F,nrow=length(x.range))
pred.matrix
plot_ly(z = ~pred.matrix) %>% add_surface()
#iterate through point from points.j
pred.table=data.frame(matrix(NA,nrow=npointsj,ncol=3))
names(pred.table)=c("agx","agy","pred.titre")
lm.data=lm.data.group[[kk]]
for(pp in 1:npointsj){
agW=rep(ag.weights[pp,],length(group.list[[kk]])) # specify weights for fitting
fit.model <- lm(titre ~ agx+agy,data=lm.data,weights=agW)
#summary(fit.model); predict(fit.model,newdata=points.j[pp,])
# predict titre for that point
pred.table[pp,] <- c(points.j[pp,],predict(fit.model,newdata=points.j[pp,]))
}
pred.tableP <- sapply(pred.table$pred.titre,function(x){min(max(x,0),8)})
pred.matrix <- matrix(pred.tableP,byrow=F,nrow=length(x.range))
plot_ly(z = ~pred.matrix) %>% add_surface()
#iterate through point from points.j
pred.table=data.frame(matrix(NA,nrow=npointsj,ncol=3))
names(pred.table)=c("agx","agy","pred.titre")
lm.data=lm.data.group[[kk]]
for(pp in 1:npointsj){
agW=rep(ag.weights[pp,],length(group.list[[kk]])) # specify weights for fitting
fit.model <- lm(titre ~ agx*agy,data=lm.data,weights=agW)
#summary(fit.model); predict(fit.model,newdata=points.j[pp,])
# predict titre for that point
pred.table[pp,] <- c(points.j[pp,],predict(fit.model,newdata=points.j[pp,]))
}
pred.tableP <- sapply(pred.table$pred.titre,function(x){min(max(x,0),8)})
pred.matrix <- matrix(pred.tableP,byrow=F,nrow=length(x.range))
plot_ly(z = ~pred.matrix) %>% add_surface()
points.j
group.list
lm.data
plot_ly(z = ~lm.data) %>% add_surface()
lm.data
plot_ly(lm.data) %>% add_surface()
names(lm.data)
plot_ly(x = ~lm.data$agx, y = ~lm.data$agy, z = ~lm.data$titre) %>% add_markers()
plot_ly(z = ~pred.matrix) %>% add_surface()
plot_ly(x = ~lm.data$agx, y = ~lm.data$agy, z = ~lm.data$titre) %>% add_markers()
plot_ly(z = ~pred.matrix) %>% add_surface()
plot_ly(x = ~lm.data$agx, y = ~lm.data$agy, z = ~lm.data$titre) %>% add_markers()
#iterate through point from points.j
pred.table=data.frame(matrix(NA,nrow=npointsj,ncol=3))
names(pred.table)=c("agx","agy","pred.titre")
lm.data=lm.data.group[[kk]]
for(pp in 1:npointsj){
agW=rep(ag.weights[pp,],length(group.list[[kk]])) # specify weights for fitting
fit.model <- lm(titre ~ agx+agy,data=lm.data,weights=agW)
#summary(fit.model); predict(fit.model,newdata=points.j[pp,])
# predict titre for that point
pred.table[pp,] <- c(points.j[pp,],predict(fit.model,newdata=points.j[pp,]))
}
pred.tableP <- sapply(pred.table$pred.titre,function(x){min(max(x,0),8)})
pred.matrix <- matrix(pred.tableP,byrow=F,nrow=length(x.range))
plot_ly(z = ~pred.matrix) %>% add_surface()
plot_ly(x = ~lm.data$agx, y = ~lm.data$agy, z = ~lm.data$titre) %>% add_markers()
agW=rep(ag.weights[pp,],length(group.list[[kk]])) # specify weights for fitting
fit.model <- lm(titre ~ agx+agy,data=lm.data,weights=agW)
fit.model
agW=rep(ag.weights[pp,],length(group.list[[kk]])) # specify weights for fitting
fit.model <- lm(titre ~ agx*agy,data=lm.data,weights=agW)
fit.model
#iterate through point from points.j
pred.table=data.frame(matrix(NA,nrow=npointsj,ncol=3))
names(pred.table)=c("agx","agy","pred.titre")
lm.data=lm.data.group[[kk]]
for(pp in 1:npointsj){
agW=rep(ag.weights[pp,],length(group.list[[kk]])) # specify weights for fitting
fit.model <- lm(titre ~ agx:agy,data=lm.data,weights=agW)
#summary(fit.model); predict(fit.model,newdata=points.j[pp,])
# predict titre for that point
pred.table[pp,] <- c(points.j[pp,],predict(fit.model,newdata=points.j[pp,]))
}
pred.tableP <- sapply(pred.table$pred.titre,function(x){min(max(x,0),8)})
pred.matrix <- matrix(pred.tableP,byrow=F,nrow=length(x.range))
plot_ly(z = ~pred.matrix) %>% add_surface()
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=25) # Generate maps
# Plot data
landscape.plot(dataload,radius1=25,yearload=2009,groupN=2)
reproduction.number.plot(dataload)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
reproduction.number.plot(dataload,rR=3)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=25) # Generate maps
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=15) # Generate maps
# Plot data
landscape.plot(dataload,radius1=15,yearload=2009,groupN=2)
reproduction.number.plot(dataload,rR=3)
#titre.plot(dataload)
#proct.plot(dataload)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=15) # Generate maps
# Plot data
landscape.plot(dataload,radius1=15,yearload=2009,groupN=2)
reproduction.number.plot(dataload,rR=3)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
# Plot data
landscape.plot(dataload,radius1=15,yearload=2009,groupN=2)
reproduction.number.plot(dataload,rR=3)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=15) # Generate maps
# Plot data
landscape.plot(dataload,radius1=15,yearload=2009,groupN=2)
reproduction.number.plot(dataload,rR=3)
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=15) # Generate maps
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=15) # Generate maps
# Plot data
landscape.plot(dataload,radius1=15,yearload=2009,groupN=2)
reproduction.number.plot(dataload,rR=3)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=15) # Generate maps
# Plot data
landscape.plot(dataload,radius1=15,yearload=2009,groupN=2)
reproduction.number.plot(dataload,rR=3)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=15) # Generate maps
# Plot data
landscape.plot(dataload,radius1=15,yearload=2009,groupN=2)
reproduction.number.plot(dataload,rR=3)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Code by Adam Kucharski (2016)
library(plot3D)
library(colorspace)
# LOAD Functions
setwd("~/Documents/antigenic-landscapes/immunity_model/")
#setwd("/Users/marcbaguelin/GitHub/antigenic-landscapes/immunity_model/")
source("model_functions.R")  #Set up functions
dataload="Fluscape_08"
#dataload="Australia_98"
landscape.build(dataload,0.5,extendD=5,bandW=15) # Generate maps
# Plot data
landscape.plot(dataload,radius1=15,yearload=2009,groupN=2)
reproduction.number.plot(dataload,rR=3)
store.crossVal = NULL
for(kk in seq(10,50,5)){
rmsq=cross.validation(Data.load=dataload,d.step=0.5,extendD=0,bandW=kk, Nsamp = 20, bootstrap = 5)
store.crossVal=cbind(store.crossVal,c(kk,rmsq))
}
write.csv(store.crossVal,"output_data/storeCross.csv")
# Plot cross validation
data <- read.csv("output_data/storeCross.csv")
data <- data[,-1]
plot(as.numeric(data[1,]),as.numeric(data[2,]))
6300/14
